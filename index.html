<!DOCTYPE html>
<html>
<head>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <title>UWCCSC_Ceremony_2025</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            background: #f5f5f5;
            overflow: hidden;
            position: relative;
            height: 100vh;
        }

        #message-container {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .message {
            position: absolute;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 18px;
            white-space: nowrap;
            opacity: 1;
            left: 0;
            transform: translateX(0%);
            animation-timing-function: linear;
            animation-fill-mode: forwards;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        @keyframes fly {
            0% {
                transform: translateX(0%);
            }
            100% {
                transform: translateX(100vw);
            }
        }

        .message {
            animation-name: fly;
            animation-duration: 30s;
            animation-timing-function: linear;
            animation-fill-mode: forwards;
        }

        #countdown {
            display: none; /* Hidden but still functional */
        }

        #qr-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            text-align: center;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 10px;
            z-index: 100;
        }

        #start-button {
            position: fixed;
            top: 20px;
            left: 20px;
            font-size: 18px;
            background: #4285f4;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 10px;
            cursor: pointer;
            z-index: 100;
        }

        #start-button:hover {
            background: #3367d6;
        }
    </style>
</head>
<body>
<button id="start-button">Start Countdown</button>
<div id="countdown"></div>
<div id="message-container"></div>
<div id="qr-container">
    <div id="qrcode"></div>
</div>

<script src="js/supabase.min.js"></script>
<script src="js/qrcode.min.js"></script>

<script>
    // Initialize Supabase
    const SUPABASE_URL = 'https://wzwvsbgmiisxloyfkqdr.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Ind6d3ZzYmdtaWlzeGxveWZrcWRyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc5MDI0OTIsImV4cCI6MjA2MzQ3ODQ5Mn0.ZbwYwH2TW4nFUUEzaIhWKZfXitDGcUEcmOwXf9Ryay4';
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // Generate QR Code
    function getBaseURL() {
        return window.location.origin;
    }
    const submitURL = `${getBaseURL()}/submit`;
    new QRCode(document.getElementById("qrcode"), {
        text: submitURL,
        width: 100,
        height: 100
    });

    // Light color palette for messages
    const colors = [
        '#FF9A76', '#FF7676', '#C5E07F', '#72D6A0', '#92CFEF',
        '#FFA4B2', '#D4E684', '#5EC3B9', '#8B9CD9', '#E48DB3',
        '#FFC97E', '#6FAED6', '#F5A6C8', '#94DFA3', '#FFB38A',
        '#86AAD5', '#D1A5FF', '#A2DFDF', '#F1C76D', '#9FBABB'
    ];

    // Variables for message queue
    let messageQueue = [];
    let isAnimating = false;
    let messageElements = [];
    let playedMessageIds = new Set();
    let planBActive = false;
    let planBTimer = null;

    // Countdown variables
    let countdownTime = 3 * 60; // 3 minutes in seconds
    let countdownInterval;

    // Start button
    const startButton = document.getElementById('start-button');

    // Function to start countdown
    function startCountdown() {
        console.log("startCountdown function called"); // Debug log
        startButton.style.display = 'none';
        countdownInterval = setInterval(() => {
            countdownTime--;
            console.log("Countdown:", countdownTime); // Debug log

            if (countdownTime <= 0) {
                console.log("Countdown finished"); // Debug log
                clearInterval(countdownInterval);
                if (planBTimer) clearInterval(planBTimer);
            }
        }, 1000);

        // Start Plan B check after 25 seconds
        setTimeout(() => {
            console.log("Checking for Plan B activation"); // Debug log
            if (messageQueue.length === 0 && !planBActive) {
                activatePlanB();
            }
        }, 25000);
    }

    // Function to activate Plan B
    async function activatePlanB() {
        planBActive = true;
        console.log("Activating Plan B - using prepared messages");

        try {
            // Fetch the planb.txt file
            console.log("Attempting to fetch planb.txt");
            const response = await fetch('planb.txt');
            console.log("planb.txt fetch response status:", response.status);
            if (!response.ok) {
                console.error('Failed to load planb.txt:', response.status, response.statusText);
                throw new Error('Failed to load planb.txt');
            }

            const text = await response.text();
            console.log("planb.txt content length:", text.length);
            // Split by newlines and filter out empty lines
            const messages = text.split('\n').filter(msg => msg.trim() !== '');
            console.log("Number of Plan B messages loaded:", messages.length);

            if (messages.length === 0) {
                console.warn('planb.txt is empty or contains no valid messages');
                throw new Error('planb.txt is empty');
            }

            // Add all Plan B messages to queue
            messages.forEach((msg, index) => {
                const planBMessage = {
                    id: `planb-${index}`,
                    text: msg.trim(),
                    isPlanB: true
                };
                messageQueue.push(planBMessage);
                console.log("Plan B message added to queue:", planBMessage); // Debug log
            });

            // Process queue if not already animating
            if (!isAnimating) {
                console.log("Processing queue after Plan B activation"); // Debug log
                processQueue();
            }
        } catch (error) {
            console.error('Error loading Plan B messages:', error);
            // Fallback to hardcoded messages if planb.txt fails
            const fallbackMessages = [
                "Congratulations to all graduates!",
                "Your hard work has paid off!",
                "The future belongs to you!",
                "Dream big and achieve bigger!",
                "Today is just the beginning!"
            ];

            fallbackMessages.forEach((msg, index) => {
                const fallbackMessage = {
                    id: `planb-fallback-${index}`,
                    text: msg,
                    isPlanB: true
                };
                messageQueue.push(fallbackMessage);
                console.log("Fallback message added to queue:", fallbackMessage); // Debug log
            });

            if (!isAnimating) {
                console.log("Processing queue after fallback Plan B messages"); // Debug log
                processQueue();
            }
        }
    }

    // Function to get a random color
    function getRandomColor() {
        const color = colors[Math.floor(Math.random() * colors.length)];
        console.log("Generated random color:", color); // Debug log
        return color;
    }

    // Function to get a random Y position (avoiding top and bottom edges)
    function getRandomYPosition() {
        const yPos = 10 + Math.random() * 70; // 10% to 80% of viewport height
        console.log("Generated random Y position:", yPos); // Debug log
        return yPos;
    }

    // Function to record a message as played
    async function recordPlayedMessage(messageId) {
        console.log("Attempting to record played message:", messageId); // Debug log
        try {
            const { error } = await supabase
                .from('played')
                .insert([{ id: messageId }]);

            if (error) {
                console.error('Error recording played message:', error); // Debug log
                throw error;
            }
            playedMessageIds.add(messageId);
            console.log("Message recorded as played:", messageId); // Debug log
        } catch (error) {
            console.error('Error recording played message:', error); // Debug log
        }
    }

    // Function to get already played messages
    async function fetchPlayedMessages() {
        console.log("Fetching already played messages"); // Debug log
        try {
            const { data, error } = await supabase
                .from('played')
                .select('id');

            if (error) {
                console.error('Error fetching played messages:', error); // Debug log
                throw error;
            }

            if (data && data.length > 0) {
                data.forEach(item => {
                    playedMessageIds.add(item.id);
                });
                console.log("Fetched played message IDs:", playedMessageIds); // Debug log
            } else {
                console.log("No played messages found."); // Debug log
            }
        } catch (error) {
            console.error('Error fetching played messages:', error); // Debug log
        }
    }

    // Function to animate a message
    function animateMessage(messageElement, duration, callback) {
        console.log("Animating message:", messageElement.textContent, "for", duration, "ms"); // Debug log
        const startTime = performance.now();
        const containerWidth = document.getElementById('message-container').clientWidth;

        function step(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // Move from left to right
            const translateX = (containerWidth * progress);
            messageElement.style.transform = `translateX(${translateX}px)`;

            // Fade out when near the end
            if (progress > 0.9) {
                messageElement.style.opacity = 1 - (progress - 0.9) * 10;
            }

            if (progress < 1) {
                requestAnimationFrame(step);
            } else {
                console.log("Animation finished for:", messageElement.textContent); // Debug log
                messageElement.remove();
                if (callback) {
                    console.log("Callback after animation for:", messageElement.textContent); // Debug log
                    callback();
                }
            }
        }

        requestAnimationFrame(step);
    }

    function processQueue() {
        if (messageQueue.length === 0) {
            console.log("Queue is empty. Returning."); // Debug log
            return;
        }

        const messageData = messageQueue.shift();
        console.log("Processing message from queue:", messageData); // Debug log

        const messageElement = document.createElement('div');
        messageElement.className = 'message';
        messageElement.textContent = messageData.text;
        messageElement.style.top = `${getRandomYPosition()}%`;
        messageElement.style.backgroundColor = getRandomColor();
        if (messageData.id) {
            messageElement.dataset.id = messageData.id;
        }

        document.getElementById('message-container').appendChild(messageElement);
        messageElements.push(messageElement);
        console.log("Message element created and added to container:", messageElement); // Debug log

        if (messageData.id && !messageData.isPlanB) {
            recordPlayedMessage(messageData.id);
        }

        messageElement.offsetHeight; // Force layout calculation

        const duration = 30000; // 30 seconds animation duration
        animateMessage(messageElement, duration, () => {
            messageElements = messageElements.filter(el => el !== messageElement);
        });

        // Schedule next message after 3 seconds
        setTimeout(() => {
            if (messageQueue.length > 0) {
                processQueue();
            }
        }, 3000);
    }

    // Function to fetch messages from Supabase
    async function fetchMessages() {
        console.log("Fetching new messages from Supabase"); // Debug log
        try {
            // Get messages from the last 5 minutes
            const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000).toISOString();
            console.log("Fetching messages since:", fiveMinutesAgo); // Debug log

            const { data, error } = await supabase
                .from('messages')
                .select('*')
                .gte('timestamp', fiveMinutesAgo)
                .order('timestamp', { ascending: true });

            if (error) {
                console.error('Error fetching messages:', error); // Debug log
                throw error;
            }

            if (data && data.length > 0) {
                console.log("Fetched messages:", data); // Debug log
                // Add new messages to queue that haven't been played
                data.forEach(message => {
                    if (!playedMessageIds.has(message.id.toString()) &&
                        !messageQueue.some(m => m.id === message.id) &&
                        !messageElements.some(el => el.dataset.id === message.id.toString())) {
                        messageQueue.push(message);
                        console.log("New message added to queue:", message); // Debug log
                    } else {
                        console.log("Message already played or in queue/DOM:", message.id); // Debug log
                    }
                });

                // Process queue if not already animating
                if (!isAnimating && messageQueue.length > 0) {
                    console.log("Processing queue after fetching new messages"); // Debug log
                    processQueue();
                }
            } else {
                console.log("No new messages fetched."); // Debug log
            }
        } catch (error) {
            console.error('Error fetching messages:', error); // Debug log
        }
    }

    // Set up real-time subscription
    function setupRealtime() {
        console.log("Setting up real-time subscription"); // Debug log
        const subscription = supabase
            .channel('messages')
            .on('postgres_changes', {
                event: 'INSERT',
                schema: 'public',
                table: 'messages'
            }, payload => {
                console.log("Realtime INSERT event received:", payload); // Debug log
                // Add new message to queue if not already played
                if (!playedMessageIds.has(payload.new.id.toString())) {
                    messageQueue.push(payload.new);
                    console.log("New realtime message added to queue:", payload.new); // Debug log
                    if (!isAnimating) {
                        console.log("Processing queue after realtime event"); // Debug log
                        processQueue();
                    }
                } else {
                    console.log("Realtime message already played:", payload.new.id); // Debug log
                }
            })
            .subscribe();
        console.log("Real-time subscription started:", subscription); // Debug log
    }

    // Initialize the page
    document.addEventListener('DOMContentLoaded', async () => {
        console.log("DOMContentLoaded event fired"); // Debug log
        await fetchPlayedMessages();
        fetchMessages();
        setupRealtime();
        startButton.addEventListener('click', () => {
            console.log("Start button clicked"); // Debug log
            startCountdown();
        });
        setInterval(() => {
            console.log("Periodic message fetch triggered"); // Debug log
            fetchMessages();
        }, 30000);
        console.log("Initialization complete"); // Debug log
    });
</script>
</body>
</html>